{"ast":null,"code":"import _defineProperty from \"C:/Users/MacBook Air/Desktop/shifai1VV/node_modules/@babel/runtime/helpers/esm/defineProperty.js\";\nvar _AngularFireStorage, _GetDownloadURLPipe, _GetDownloadURLPipeModule, _AngularFireStorageModule;\nimport * as i1 from '@angular/fire';\nimport { observeOutsideAngular, keepUnstableUntilFirst, VERSION } from '@angular/fire';\nimport { Observable, of, from } from 'rxjs';\nimport { debounceTime, map, switchMap, tap } from 'rxjs/operators';\nimport * as i0 from '@angular/core';\nimport { InjectionToken, PLATFORM_ID, Injectable, Inject, Optional, Pipe, NgModule } from '@angular/core';\nimport * as i2 from '@angular/fire/app-check';\nimport { ɵfirebaseAppFactory, ɵcacheInstance, FIREBASE_OPTIONS, FIREBASE_APP_NAME } from '@angular/fire/compat';\nimport 'firebase/compat/storage';\nimport firebase from 'firebase/compat/app';\nimport { AsyncPipe } from '@angular/common';\nimport * as i2$1 from '@angular/platform-browser';\nimport { makeStateKey } from '@angular/platform-browser';\n\n// need to import, else the types become import('firebase/compat/app').default.storage.UploadTask\n// and it no longer works w/Firebase v7\n// Things aren't working great, I'm having to put in a lot of work-arounds for what\n// appear to be Firebase JS SDK bugs https://github.com/firebase/firebase-js-sdk/issues/4158\nfunction fromTask(task) {\n  return new Observable(subscriber => {\n    const progress = snap => subscriber.next(snap);\n    const error = e => subscriber.error(e);\n    const complete = () => subscriber.complete();\n    // emit the current snapshot, so they don't have to wait for state_changes\n    // to fire next... this is stale if the task is no longer running :(\n    progress(task.snapshot);\n    const unsub = task.on('state_changed', progress);\n    // it turns out that neither task snapshot nor 'state_changed' fire the last\n    // snapshot before completion, the one with status 'success\" and 100% progress\n    // so let's use the promise form of the task for that\n    task.then(snapshot => {\n      progress(snapshot);\n      complete();\n    }, e => {\n      // TODO investigate, again this is stale, we never fire a canceled or error it seems\n      progress(task.snapshot);\n      error(e);\n    });\n    // on's type if Function, rather than () => void, need to wrap\n    return function unsubscribe() {\n      unsub();\n    };\n  }).pipe(\n  // deal with sync emissions from first emitting `task.snapshot`, this makes sure\n  // that if the task is already finished we don't emit the old running state\n  debounceTime(0));\n}\n\n/**\n * Create an AngularFireUploadTask from a regular UploadTask from the Storage SDK.\n * This method creates an observable of the upload and returns on object that provides\n * multiple methods for controlling and monitoring the file upload.\n */\nfunction createUploadTask(task) {\n  const inner$ = fromTask(task);\n  return {\n    task,\n    then: task.then.bind(task),\n    catch: task.catch.bind(task),\n    pause: task.pause.bind(task),\n    cancel: task.cancel.bind(task),\n    resume: task.resume.bind(task),\n    snapshotChanges: () => inner$,\n    percentageChanges: () => inner$.pipe(map(s => s.bytesTransferred / s.totalBytes * 100))\n  };\n}\n\n/**\n * Create an AngularFire wrapped Storage Reference. This object\n * creates observable methods from promise based methods.\n */\nfunction createStorageRef(ref) {\n  return {\n    getDownloadURL: () => of(undefined).pipe(observeOutsideAngular, switchMap(() => ref.getDownloadURL()), keepUnstableUntilFirst),\n    getMetadata: () => of(undefined).pipe(observeOutsideAngular, switchMap(() => ref.getMetadata()), keepUnstableUntilFirst),\n    delete: () => from(ref.delete()),\n    child: path => createStorageRef(ref.child(path)),\n    updateMetadata: meta => from(ref.updateMetadata(meta)),\n    put: (data, metadata) => {\n      const task = ref.put(data, metadata);\n      return createUploadTask(task);\n    },\n    putString: (data, format, metadata) => {\n      const task = ref.putString(data, format, metadata);\n      return createUploadTask(task);\n    },\n    list: options => from(ref.list(options)),\n    listAll: () => from(ref.listAll())\n  };\n}\nconst BUCKET = new InjectionToken('angularfire2.storageBucket');\nconst MAX_UPLOAD_RETRY_TIME = new InjectionToken('angularfire2.storage.maxUploadRetryTime');\nconst MAX_OPERATION_RETRY_TIME = new InjectionToken('angularfire2.storage.maxOperationRetryTime');\nconst USE_EMULATOR = new InjectionToken('angularfire2.storage.use-emulator');\n/**\n * AngularFireStorage Service\n *\n * This service is the main entry point for this feature module. It provides\n * an API for uploading and downloading binary files from Cloud Storage for\n * Firebase.\n */\nclass AngularFireStorage {\n  constructor(options, name, storageBucket,\n  // eslint-disable-next-line @typescript-eslint/ban-types\n  platformId, zone, schedulers, maxUploadRetryTime, maxOperationRetryTime, _useEmulator, _appCheckInstances) {\n    _defineProperty(this, \"storage\", void 0);\n    const app = ɵfirebaseAppFactory(options, zone, name);\n    this.storage = ɵcacheInstance(`${app.name}.storage.${storageBucket}`, 'AngularFireStorage', app.name, () => {\n      const storage = zone.runOutsideAngular(() => app.storage(storageBucket || undefined));\n      const useEmulator = _useEmulator;\n      if (useEmulator) {\n        storage.useEmulator(...useEmulator);\n      }\n      if (maxUploadRetryTime) {\n        storage.setMaxUploadRetryTime(maxUploadRetryTime);\n      }\n      if (maxOperationRetryTime) {\n        storage.setMaxOperationRetryTime(maxOperationRetryTime);\n      }\n      return storage;\n    }, [maxUploadRetryTime, maxOperationRetryTime]);\n  }\n  ref(path) {\n    return createStorageRef(this.storage.ref(path));\n  }\n  refFromURL(path) {\n    return createStorageRef(this.storage.refFromURL(path));\n  }\n  upload(path, data, metadata) {\n    const storageRef = this.storage.ref(path);\n    const ref = createStorageRef(storageRef);\n    return ref.put(data, metadata);\n  }\n}\n_AngularFireStorage = AngularFireStorage;\n_defineProperty(AngularFireStorage, \"\\u0275fac\", function _AngularFireStorage_Factory(t) {\n  return new (t || _AngularFireStorage)(i0.ɵɵinject(FIREBASE_OPTIONS), i0.ɵɵinject(FIREBASE_APP_NAME, 8), i0.ɵɵinject(BUCKET, 8), i0.ɵɵinject(PLATFORM_ID), i0.ɵɵinject(i0.NgZone), i0.ɵɵinject(i1.ɵAngularFireSchedulers), i0.ɵɵinject(MAX_UPLOAD_RETRY_TIME, 8), i0.ɵɵinject(MAX_OPERATION_RETRY_TIME, 8), i0.ɵɵinject(USE_EMULATOR, 8), i0.ɵɵinject(i2.AppCheckInstances, 8));\n});\n_defineProperty(AngularFireStorage, \"\\u0275prov\", /* @__PURE__ */i0.ɵɵdefineInjectable({\n  token: _AngularFireStorage,\n  factory: _AngularFireStorage.ɵfac,\n  providedIn: 'any'\n}));\n(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(AngularFireStorage, [{\n    type: Injectable,\n    args: [{\n      providedIn: 'any'\n    }]\n  }], function () {\n    return [{\n      type: undefined,\n      decorators: [{\n        type: Inject,\n        args: [FIREBASE_OPTIONS]\n      }]\n    }, {\n      type: undefined,\n      decorators: [{\n        type: Optional\n      }, {\n        type: Inject,\n        args: [FIREBASE_APP_NAME]\n      }]\n    }, {\n      type: undefined,\n      decorators: [{\n        type: Optional\n      }, {\n        type: Inject,\n        args: [BUCKET]\n      }]\n    }, {\n      type: Object,\n      decorators: [{\n        type: Inject,\n        args: [PLATFORM_ID]\n      }]\n    }, {\n      type: i0.NgZone\n    }, {\n      type: i1.ɵAngularFireSchedulers\n    }, {\n      type: undefined,\n      decorators: [{\n        type: Optional\n      }, {\n        type: Inject,\n        args: [MAX_UPLOAD_RETRY_TIME]\n      }]\n    }, {\n      type: undefined,\n      decorators: [{\n        type: Optional\n      }, {\n        type: Inject,\n        args: [MAX_OPERATION_RETRY_TIME]\n      }]\n    }, {\n      type: undefined,\n      decorators: [{\n        type: Optional\n      }, {\n        type: Inject,\n        args: [USE_EMULATOR]\n      }]\n    }, {\n      type: i2.AppCheckInstances,\n      decorators: [{\n        type: Optional\n      }]\n    }];\n  }, null);\n})();\n\n/** to be used with in combination with | async */\nclass GetDownloadURLPipe {\n  constructor(storage, cdr, state) {\n    _defineProperty(this, \"storage\", void 0);\n    _defineProperty(this, \"state\", void 0);\n    _defineProperty(this, \"asyncPipe\", void 0);\n    _defineProperty(this, \"path\", void 0);\n    _defineProperty(this, \"downloadUrl$\", void 0);\n    this.storage = storage;\n    this.state = state;\n    this.asyncPipe = new AsyncPipe(cdr);\n  }\n  transform(path) {\n    if (path !== this.path) {\n      var _this$state;\n      this.path = path;\n      const key = makeStateKey(`|getDownloadURL|${path}`);\n      const existing = (_this$state = this.state) === null || _this$state === void 0 ? void 0 : _this$state.get(key, undefined);\n      this.downloadUrl$ = existing ? of(existing) : this.storage.ref(path).getDownloadURL().pipe(tap(it => {\n        var _this$state2;\n        return (_this$state2 = this.state) === null || _this$state2 === void 0 ? void 0 : _this$state2.set(key, it);\n      }));\n    }\n    return this.asyncPipe.transform(this.downloadUrl$);\n  }\n  ngOnDestroy() {\n    this.asyncPipe.ngOnDestroy();\n  }\n}\n_GetDownloadURLPipe = GetDownloadURLPipe;\n_defineProperty(GetDownloadURLPipe, \"\\u0275fac\", function _GetDownloadURLPipe_Factory(t) {\n  return new (t || _GetDownloadURLPipe)(i0.ɵɵdirectiveInject(AngularFireStorage, 16), i0.ɵɵdirectiveInject(i0.ChangeDetectorRef, 16), i0.ɵɵdirectiveInject(i2$1.TransferState, 24));\n});\n_defineProperty(GetDownloadURLPipe, \"\\u0275pipe\", /* @__PURE__ */i0.ɵɵdefinePipe({\n  name: \"getDownloadURL\",\n  type: _GetDownloadURLPipe,\n  pure: false\n}));\n(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(GetDownloadURLPipe, [{\n    type: Pipe,\n    args: [{\n      name: 'getDownloadURL',\n      pure: false\n    }]\n  }], function () {\n    return [{\n      type: AngularFireStorage\n    }, {\n      type: i0.ChangeDetectorRef\n    }, {\n      type: i2$1.TransferState,\n      decorators: [{\n        type: Optional\n      }]\n    }];\n  }, null);\n})();\nclass GetDownloadURLPipeModule {}\n_GetDownloadURLPipeModule = GetDownloadURLPipeModule;\n_defineProperty(GetDownloadURLPipeModule, \"\\u0275fac\", function _GetDownloadURLPipeModule_Factory(t) {\n  return new (t || _GetDownloadURLPipeModule)();\n});\n_defineProperty(GetDownloadURLPipeModule, \"\\u0275mod\", /* @__PURE__ */i0.ɵɵdefineNgModule({\n  type: _GetDownloadURLPipeModule\n}));\n_defineProperty(GetDownloadURLPipeModule, \"\\u0275inj\", /* @__PURE__ */i0.ɵɵdefineInjector({}));\n(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(GetDownloadURLPipeModule, [{\n    type: NgModule,\n    args: [{\n      declarations: [GetDownloadURLPipe],\n      exports: [GetDownloadURLPipe]\n    }]\n  }], null, null);\n})();\nclass AngularFireStorageModule {\n  constructor() {\n    firebase.registerVersion('angularfire', VERSION.full, 'gcs-compat');\n  }\n}\n_AngularFireStorageModule = AngularFireStorageModule;\n_defineProperty(AngularFireStorageModule, \"\\u0275fac\", function _AngularFireStorageModule_Factory(t) {\n  return new (t || _AngularFireStorageModule)();\n});\n_defineProperty(AngularFireStorageModule, \"\\u0275mod\", /* @__PURE__ */i0.ɵɵdefineNgModule({\n  type: _AngularFireStorageModule\n}));\n_defineProperty(AngularFireStorageModule, \"\\u0275inj\", /* @__PURE__ */i0.ɵɵdefineInjector({\n  providers: [AngularFireStorage],\n  imports: [GetDownloadURLPipeModule]\n}));\n(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(AngularFireStorageModule, [{\n    type: NgModule,\n    args: [{\n      exports: [GetDownloadURLPipeModule],\n      providers: [AngularFireStorage]\n    }]\n  }], function () {\n    return [];\n  }, null);\n})();\n\n/**\n * Generated bundle index. Do not edit.\n */\n\nexport { AngularFireStorage, AngularFireStorageModule, BUCKET, GetDownloadURLPipe, GetDownloadURLPipeModule, MAX_OPERATION_RETRY_TIME, MAX_UPLOAD_RETRY_TIME, USE_EMULATOR, createStorageRef, createUploadTask, fromTask };","map":{"version":3,"names":["i1","observeOutsideAngular","keepUnstableUntilFirst","VERSION","Observable","of","from","debounceTime","map","switchMap","tap","i0","InjectionToken","PLATFORM_ID","Injectable","Inject","Optional","Pipe","NgModule","i2","ɵfirebaseAppFactory","ɵcacheInstance","FIREBASE_OPTIONS","FIREBASE_APP_NAME","firebase","AsyncPipe","i2$1","makeStateKey","fromTask","task","subscriber","progress","snap","next","error","e","complete","snapshot","unsub","on","then","unsubscribe","pipe","createUploadTask","inner$","bind","catch","pause","cancel","resume","snapshotChanges","percentageChanges","s","bytesTransferred","totalBytes","createStorageRef","ref","getDownloadURL","undefined","getMetadata","delete","child","path","updateMetadata","meta","put","data","metadata","putString","format","list","options","listAll","BUCKET","MAX_UPLOAD_RETRY_TIME","MAX_OPERATION_RETRY_TIME","USE_EMULATOR","AngularFireStorage","constructor","name","storageBucket","platformId","zone","schedulers","maxUploadRetryTime","maxOperationRetryTime","_useEmulator","_appCheckInstances","_defineProperty","app","storage","runOutsideAngular","useEmulator","setMaxUploadRetryTime","setMaxOperationRetryTime","refFromURL","upload","storageRef","_AngularFireStorage","_AngularFireStorage_Factory","t","ɵɵinject","NgZone","ɵAngularFireSchedulers","AppCheckInstances","ɵɵdefineInjectable","token","factory","ɵfac","providedIn","ngDevMode","ɵsetClassMetadata","type","args","decorators","Object","GetDownloadURLPipe","cdr","state","asyncPipe","transform","_this$state","key","existing","get","downloadUrl$","it","_this$state2","set","ngOnDestroy","_GetDownloadURLPipe","_GetDownloadURLPipe_Factory","ɵɵdirectiveInject","ChangeDetectorRef","TransferState","ɵɵdefinePipe","pure","GetDownloadURLPipeModule","_GetDownloadURLPipeModule","_GetDownloadURLPipeModule_Factory","ɵɵdefineNgModule","ɵɵdefineInjector","declarations","exports","AngularFireStorageModule","registerVersion","full","_AngularFireStorageModule","_AngularFireStorageModule_Factory","providers","imports"],"sources":["C:/Users/MacBook Air/Desktop/shifai1VV/node_modules/@angular/fire/fesm2022/angular-fire-compat-storage.mjs"],"sourcesContent":["import * as i1 from '@angular/fire';\nimport { observeOutsideAngular, keepUnstableUntilFirst, VERSION } from '@angular/fire';\nimport { Observable, of, from } from 'rxjs';\nimport { debounceTime, map, switchMap, tap } from 'rxjs/operators';\nimport * as i0 from '@angular/core';\nimport { InjectionToken, PLATFORM_ID, Injectable, Inject, Optional, Pipe, NgModule } from '@angular/core';\nimport * as i2 from '@angular/fire/app-check';\nimport { ɵfirebaseAppFactory, ɵcacheInstance, FIREBASE_OPTIONS, FIREBASE_APP_NAME } from '@angular/fire/compat';\nimport 'firebase/compat/storage';\nimport firebase from 'firebase/compat/app';\nimport { AsyncPipe } from '@angular/common';\nimport * as i2$1 from '@angular/platform-browser';\nimport { makeStateKey } from '@angular/platform-browser';\n\n// need to import, else the types become import('firebase/compat/app').default.storage.UploadTask\n// and it no longer works w/Firebase v7\n// Things aren't working great, I'm having to put in a lot of work-arounds for what\n// appear to be Firebase JS SDK bugs https://github.com/firebase/firebase-js-sdk/issues/4158\nfunction fromTask(task) {\n    return new Observable(subscriber => {\n        const progress = (snap) => subscriber.next(snap);\n        const error = e => subscriber.error(e);\n        const complete = () => subscriber.complete();\n        // emit the current snapshot, so they don't have to wait for state_changes\n        // to fire next... this is stale if the task is no longer running :(\n        progress(task.snapshot);\n        const unsub = task.on('state_changed', progress);\n        // it turns out that neither task snapshot nor 'state_changed' fire the last\n        // snapshot before completion, the one with status 'success\" and 100% progress\n        // so let's use the promise form of the task for that\n        task.then(snapshot => {\n            progress(snapshot);\n            complete();\n        }, e => {\n            // TODO investigate, again this is stale, we never fire a canceled or error it seems\n            progress(task.snapshot);\n            error(e);\n        });\n        // on's type if Function, rather than () => void, need to wrap\n        return function unsubscribe() {\n            unsub();\n        };\n    }).pipe(\n    // deal with sync emissions from first emitting `task.snapshot`, this makes sure\n    // that if the task is already finished we don't emit the old running state\n    debounceTime(0));\n}\n\n/**\n * Create an AngularFireUploadTask from a regular UploadTask from the Storage SDK.\n * This method creates an observable of the upload and returns on object that provides\n * multiple methods for controlling and monitoring the file upload.\n */\nfunction createUploadTask(task) {\n    const inner$ = fromTask(task);\n    return {\n        task,\n        then: task.then.bind(task),\n        catch: task.catch.bind(task),\n        pause: task.pause.bind(task),\n        cancel: task.cancel.bind(task),\n        resume: task.resume.bind(task),\n        snapshotChanges: () => inner$,\n        percentageChanges: () => inner$.pipe(map(s => s.bytesTransferred / s.totalBytes * 100))\n    };\n}\n\n/**\n * Create an AngularFire wrapped Storage Reference. This object\n * creates observable methods from promise based methods.\n */\nfunction createStorageRef(ref) {\n    return {\n        getDownloadURL: () => of(undefined).pipe(observeOutsideAngular, switchMap(() => ref.getDownloadURL()), keepUnstableUntilFirst),\n        getMetadata: () => of(undefined).pipe(observeOutsideAngular, switchMap(() => ref.getMetadata()), keepUnstableUntilFirst),\n        delete: () => from(ref.delete()),\n        child: (path) => createStorageRef(ref.child(path)),\n        updateMetadata: (meta) => from(ref.updateMetadata(meta)),\n        put: (data, metadata) => {\n            const task = ref.put(data, metadata);\n            return createUploadTask(task);\n        },\n        putString: (data, format, metadata) => {\n            const task = ref.putString(data, format, metadata);\n            return createUploadTask(task);\n        },\n        list: (options) => from(ref.list(options)),\n        listAll: () => from(ref.listAll())\n    };\n}\n\nconst BUCKET = new InjectionToken('angularfire2.storageBucket');\nconst MAX_UPLOAD_RETRY_TIME = new InjectionToken('angularfire2.storage.maxUploadRetryTime');\nconst MAX_OPERATION_RETRY_TIME = new InjectionToken('angularfire2.storage.maxOperationRetryTime');\nconst USE_EMULATOR = new InjectionToken('angularfire2.storage.use-emulator');\n/**\n * AngularFireStorage Service\n *\n * This service is the main entry point for this feature module. It provides\n * an API for uploading and downloading binary files from Cloud Storage for\n * Firebase.\n */\nclass AngularFireStorage {\n    storage;\n    constructor(options, name, storageBucket, \n    // eslint-disable-next-line @typescript-eslint/ban-types\n    platformId, zone, schedulers, maxUploadRetryTime, maxOperationRetryTime, _useEmulator, _appCheckInstances) {\n        const app = ɵfirebaseAppFactory(options, zone, name);\n        this.storage = ɵcacheInstance(`${app.name}.storage.${storageBucket}`, 'AngularFireStorage', app.name, () => {\n            const storage = zone.runOutsideAngular(() => app.storage(storageBucket || undefined));\n            const useEmulator = _useEmulator;\n            if (useEmulator) {\n                storage.useEmulator(...useEmulator);\n            }\n            if (maxUploadRetryTime) {\n                storage.setMaxUploadRetryTime(maxUploadRetryTime);\n            }\n            if (maxOperationRetryTime) {\n                storage.setMaxOperationRetryTime(maxOperationRetryTime);\n            }\n            return storage;\n        }, [maxUploadRetryTime, maxOperationRetryTime]);\n    }\n    ref(path) {\n        return createStorageRef(this.storage.ref(path));\n    }\n    refFromURL(path) {\n        return createStorageRef(this.storage.refFromURL(path));\n    }\n    upload(path, data, metadata) {\n        const storageRef = this.storage.ref(path);\n        const ref = createStorageRef(storageRef);\n        return ref.put(data, metadata);\n    }\n    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"16.2.10\", ngImport: i0, type: AngularFireStorage, deps: [{ token: FIREBASE_OPTIONS }, { token: FIREBASE_APP_NAME, optional: true }, { token: BUCKET, optional: true }, { token: PLATFORM_ID }, { token: i0.NgZone }, { token: i1.ɵAngularFireSchedulers }, { token: MAX_UPLOAD_RETRY_TIME, optional: true }, { token: MAX_OPERATION_RETRY_TIME, optional: true }, { token: USE_EMULATOR, optional: true }, { token: i2.AppCheckInstances, optional: true }], target: i0.ɵɵFactoryTarget.Injectable });\n    static ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: \"12.0.0\", version: \"16.2.10\", ngImport: i0, type: AngularFireStorage, providedIn: 'any' });\n}\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"16.2.10\", ngImport: i0, type: AngularFireStorage, decorators: [{\n            type: Injectable,\n            args: [{\n                    providedIn: 'any'\n                }]\n        }], ctorParameters: function () { return [{ type: undefined, decorators: [{\n                    type: Inject,\n                    args: [FIREBASE_OPTIONS]\n                }] }, { type: undefined, decorators: [{\n                    type: Optional\n                }, {\n                    type: Inject,\n                    args: [FIREBASE_APP_NAME]\n                }] }, { type: undefined, decorators: [{\n                    type: Optional\n                }, {\n                    type: Inject,\n                    args: [BUCKET]\n                }] }, { type: Object, decorators: [{\n                    type: Inject,\n                    args: [PLATFORM_ID]\n                }] }, { type: i0.NgZone }, { type: i1.ɵAngularFireSchedulers }, { type: undefined, decorators: [{\n                    type: Optional\n                }, {\n                    type: Inject,\n                    args: [MAX_UPLOAD_RETRY_TIME]\n                }] }, { type: undefined, decorators: [{\n                    type: Optional\n                }, {\n                    type: Inject,\n                    args: [MAX_OPERATION_RETRY_TIME]\n                }] }, { type: undefined, decorators: [{\n                    type: Optional\n                }, {\n                    type: Inject,\n                    args: [USE_EMULATOR]\n                }] }, { type: i2.AppCheckInstances, decorators: [{\n                    type: Optional\n                }] }]; } });\n\n/** to be used with in combination with | async */\nclass GetDownloadURLPipe {\n    storage;\n    state;\n    asyncPipe;\n    path;\n    downloadUrl$;\n    constructor(storage, cdr, state) {\n        this.storage = storage;\n        this.state = state;\n        this.asyncPipe = new AsyncPipe(cdr);\n    }\n    transform(path) {\n        if (path !== this.path) {\n            this.path = path;\n            const key = makeStateKey(`|getDownloadURL|${path}`);\n            const existing = this.state?.get(key, undefined);\n            this.downloadUrl$ = existing ? of(existing) : this.storage.ref(path).getDownloadURL().pipe(tap(it => this.state?.set(key, it)));\n        }\n        return this.asyncPipe.transform(this.downloadUrl$);\n    }\n    ngOnDestroy() {\n        this.asyncPipe.ngOnDestroy();\n    }\n    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"16.2.10\", ngImport: i0, type: GetDownloadURLPipe, deps: [{ token: AngularFireStorage }, { token: i0.ChangeDetectorRef }, { token: i2$1.TransferState, optional: true }], target: i0.ɵɵFactoryTarget.Pipe });\n    static ɵpipe = i0.ɵɵngDeclarePipe({ minVersion: \"14.0.0\", version: \"16.2.10\", ngImport: i0, type: GetDownloadURLPipe, name: \"getDownloadURL\", pure: false });\n}\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"16.2.10\", ngImport: i0, type: GetDownloadURLPipe, decorators: [{\n            type: Pipe,\n            args: [{\n                    name: 'getDownloadURL',\n                    pure: false,\n                }]\n        }], ctorParameters: function () { return [{ type: AngularFireStorage }, { type: i0.ChangeDetectorRef }, { type: i2$1.TransferState, decorators: [{\n                    type: Optional\n                }] }]; } });\nclass GetDownloadURLPipeModule {\n    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"16.2.10\", ngImport: i0, type: GetDownloadURLPipeModule, deps: [], target: i0.ɵɵFactoryTarget.NgModule });\n    static ɵmod = i0.ɵɵngDeclareNgModule({ minVersion: \"14.0.0\", version: \"16.2.10\", ngImport: i0, type: GetDownloadURLPipeModule, declarations: [GetDownloadURLPipe], exports: [GetDownloadURLPipe] });\n    static ɵinj = i0.ɵɵngDeclareInjector({ minVersion: \"12.0.0\", version: \"16.2.10\", ngImport: i0, type: GetDownloadURLPipeModule });\n}\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"16.2.10\", ngImport: i0, type: GetDownloadURLPipeModule, decorators: [{\n            type: NgModule,\n            args: [{\n                    declarations: [GetDownloadURLPipe],\n                    exports: [GetDownloadURLPipe],\n                }]\n        }] });\n\nclass AngularFireStorageModule {\n    constructor() {\n        firebase.registerVersion('angularfire', VERSION.full, 'gcs-compat');\n    }\n    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"16.2.10\", ngImport: i0, type: AngularFireStorageModule, deps: [], target: i0.ɵɵFactoryTarget.NgModule });\n    static ɵmod = i0.ɵɵngDeclareNgModule({ minVersion: \"14.0.0\", version: \"16.2.10\", ngImport: i0, type: AngularFireStorageModule, exports: [GetDownloadURLPipeModule] });\n    static ɵinj = i0.ɵɵngDeclareInjector({ minVersion: \"12.0.0\", version: \"16.2.10\", ngImport: i0, type: AngularFireStorageModule, providers: [AngularFireStorage], imports: [GetDownloadURLPipeModule] });\n}\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"16.2.10\", ngImport: i0, type: AngularFireStorageModule, decorators: [{\n            type: NgModule,\n            args: [{\n                    exports: [GetDownloadURLPipeModule],\n                    providers: [AngularFireStorage]\n                }]\n        }], ctorParameters: function () { return []; } });\n\n/**\n * Generated bundle index. Do not edit.\n */\n\nexport { AngularFireStorage, AngularFireStorageModule, BUCKET, GetDownloadURLPipe, GetDownloadURLPipeModule, MAX_OPERATION_RETRY_TIME, MAX_UPLOAD_RETRY_TIME, USE_EMULATOR, createStorageRef, createUploadTask, fromTask };\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}