{"ast":null,"code":"var _SpyLocation, _MockLocationStrategy, _MockPlatformLocation;\n/**\n * @license Angular v17.1.2\n * (c) 2010-2022 Google LLC. https://angular.io/\n * License: MIT\n */\n\nimport { ɵnormalizeQueryParams, LocationStrategy, Location } from '@angular/common';\nimport * as i0 from '@angular/core';\nimport { EventEmitter, Injectable, InjectionToken, Inject, Optional } from '@angular/core';\nimport { Subject } from 'rxjs';\n\n/**\n * A spy for {@link Location} that allows tests to fire simulated location events.\n *\n * @publicApi\n */\nclass SpyLocation {\n  constructor() {\n    this.urlChanges = [];\n    this._history = [new LocationState('', '', null)];\n    this._historyIndex = 0;\n    /** @internal */\n    this._subject = new EventEmitter();\n    /** @internal */\n    this._basePath = '';\n    /** @internal */\n    this._locationStrategy = null;\n    /** @internal */\n    this._urlChangeListeners = [];\n    /** @internal */\n    this._urlChangeSubscription = null;\n  }\n  /** @nodoc */\n  ngOnDestroy() {\n    var _this$_urlChangeSubsc;\n    (_this$_urlChangeSubsc = this._urlChangeSubscription) === null || _this$_urlChangeSubsc === void 0 || _this$_urlChangeSubsc.unsubscribe();\n    this._urlChangeListeners = [];\n  }\n  setInitialPath(url) {\n    this._history[this._historyIndex].path = url;\n  }\n  setBaseHref(url) {\n    this._basePath = url;\n  }\n  path() {\n    return this._history[this._historyIndex].path;\n  }\n  getState() {\n    return this._history[this._historyIndex].state;\n  }\n  isCurrentPathEqualTo(path, query = '') {\n    const givenPath = path.endsWith('/') ? path.substring(0, path.length - 1) : path;\n    const currPath = this.path().endsWith('/') ? this.path().substring(0, this.path().length - 1) : this.path();\n    return currPath == givenPath + (query.length > 0 ? '?' + query : '');\n  }\n  simulateUrlPop(pathname) {\n    this._subject.emit({\n      'url': pathname,\n      'pop': true,\n      'type': 'popstate'\n    });\n  }\n  simulateHashChange(pathname) {\n    const path = this.prepareExternalUrl(pathname);\n    this.pushHistory(path, '', null);\n    this.urlChanges.push('hash: ' + pathname);\n    // the browser will automatically fire popstate event before each `hashchange` event, so we need\n    // to simulate it.\n    this._subject.emit({\n      'url': pathname,\n      'pop': true,\n      'type': 'popstate'\n    });\n    this._subject.emit({\n      'url': pathname,\n      'pop': true,\n      'type': 'hashchange'\n    });\n  }\n  prepareExternalUrl(url) {\n    if (url.length > 0 && !url.startsWith('/')) {\n      url = '/' + url;\n    }\n    return this._basePath + url;\n  }\n  go(path, query = '', state = null) {\n    path = this.prepareExternalUrl(path);\n    this.pushHistory(path, query, state);\n    const locationState = this._history[this._historyIndex - 1];\n    if (locationState.path == path && locationState.query == query) {\n      return;\n    }\n    const url = path + (query.length > 0 ? '?' + query : '');\n    this.urlChanges.push(url);\n    this._notifyUrlChangeListeners(path + ɵnormalizeQueryParams(query), state);\n  }\n  replaceState(path, query = '', state = null) {\n    path = this.prepareExternalUrl(path);\n    const history = this._history[this._historyIndex];\n    history.state = state;\n    if (history.path == path && history.query == query) {\n      return;\n    }\n    history.path = path;\n    history.query = query;\n    const url = path + (query.length > 0 ? '?' + query : '');\n    this.urlChanges.push('replace: ' + url);\n    this._notifyUrlChangeListeners(path + ɵnormalizeQueryParams(query), state);\n  }\n  forward() {\n    if (this._historyIndex < this._history.length - 1) {\n      this._historyIndex++;\n      this._subject.emit({\n        'url': this.path(),\n        'state': this.getState(),\n        'pop': true,\n        'type': 'popstate'\n      });\n    }\n  }\n  back() {\n    if (this._historyIndex > 0) {\n      this._historyIndex--;\n      this._subject.emit({\n        'url': this.path(),\n        'state': this.getState(),\n        'pop': true,\n        'type': 'popstate'\n      });\n    }\n  }\n  historyGo(relativePosition = 0) {\n    const nextPageIndex = this._historyIndex + relativePosition;\n    if (nextPageIndex >= 0 && nextPageIndex < this._history.length) {\n      this._historyIndex = nextPageIndex;\n      this._subject.emit({\n        'url': this.path(),\n        'state': this.getState(),\n        'pop': true,\n        'type': 'popstate'\n      });\n    }\n  }\n  onUrlChange(fn) {\n    var _this$_urlChangeSubsc2;\n    this._urlChangeListeners.push(fn);\n    (_this$_urlChangeSubsc2 = this._urlChangeSubscription) !== null && _this$_urlChangeSubsc2 !== void 0 ? _this$_urlChangeSubsc2 : this._urlChangeSubscription = this.subscribe(v => {\n      this._notifyUrlChangeListeners(v.url, v.state);\n    });\n    return () => {\n      const fnIndex = this._urlChangeListeners.indexOf(fn);\n      this._urlChangeListeners.splice(fnIndex, 1);\n      if (this._urlChangeListeners.length === 0) {\n        var _this$_urlChangeSubsc3;\n        (_this$_urlChangeSubsc3 = this._urlChangeSubscription) === null || _this$_urlChangeSubsc3 === void 0 || _this$_urlChangeSubsc3.unsubscribe();\n        this._urlChangeSubscription = null;\n      }\n    };\n  }\n  /** @internal */\n  _notifyUrlChangeListeners(url = '', state) {\n    this._urlChangeListeners.forEach(fn => fn(url, state));\n  }\n  subscribe(onNext, onThrow, onReturn) {\n    return this._subject.subscribe({\n      next: onNext,\n      error: onThrow,\n      complete: onReturn\n    });\n  }\n  normalize(url) {\n    return null;\n  }\n  pushHistory(path, query, state) {\n    if (this._historyIndex > 0) {\n      this._history.splice(this._historyIndex + 1);\n    }\n    this._history.push(new LocationState(path, query, state));\n    this._historyIndex = this._history.length - 1;\n  }\n}\n_SpyLocation = SpyLocation;\n_SpyLocation.ɵfac = function _SpyLocation_Factory(t) {\n  return new (t || _SpyLocation)();\n};\n_SpyLocation.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n  token: _SpyLocation,\n  factory: _SpyLocation.ɵfac\n});\n(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(SpyLocation, [{\n    type: Injectable\n  }], null, null);\n})();\nclass LocationState {\n  constructor(path, query, state) {\n    this.path = path;\n    this.query = query;\n    this.state = state;\n  }\n}\n\n/**\n * A mock implementation of {@link LocationStrategy} that allows tests to fire simulated\n * location events.\n *\n * @publicApi\n */\nclass MockLocationStrategy extends LocationStrategy {\n  constructor() {\n    super();\n    this.internalBaseHref = '/';\n    this.internalPath = '/';\n    this.internalTitle = '';\n    this.urlChanges = [];\n    /** @internal */\n    this._subject = new EventEmitter();\n    this.stateChanges = [];\n  }\n  simulatePopState(url) {\n    this.internalPath = url;\n    this._subject.emit(new _MockPopStateEvent(this.path()));\n  }\n  path(includeHash = false) {\n    return this.internalPath;\n  }\n  prepareExternalUrl(internal) {\n    if (internal.startsWith('/') && this.internalBaseHref.endsWith('/')) {\n      return this.internalBaseHref + internal.substring(1);\n    }\n    return this.internalBaseHref + internal;\n  }\n  pushState(ctx, title, path, query) {\n    // Add state change to changes array\n    this.stateChanges.push(ctx);\n    this.internalTitle = title;\n    const url = path + (query.length > 0 ? '?' + query : '');\n    this.internalPath = url;\n    const externalUrl = this.prepareExternalUrl(url);\n    this.urlChanges.push(externalUrl);\n  }\n  replaceState(ctx, title, path, query) {\n    // Reset the last index of stateChanges to the ctx (state) object\n    this.stateChanges[(this.stateChanges.length || 1) - 1] = ctx;\n    this.internalTitle = title;\n    const url = path + (query.length > 0 ? '?' + query : '');\n    this.internalPath = url;\n    const externalUrl = this.prepareExternalUrl(url);\n    this.urlChanges.push('replace: ' + externalUrl);\n  }\n  onPopState(fn) {\n    this._subject.subscribe({\n      next: fn\n    });\n  }\n  getBaseHref() {\n    return this.internalBaseHref;\n  }\n  back() {\n    if (this.urlChanges.length > 0) {\n      this.urlChanges.pop();\n      this.stateChanges.pop();\n      const nextUrl = this.urlChanges.length > 0 ? this.urlChanges[this.urlChanges.length - 1] : '';\n      this.simulatePopState(nextUrl);\n    }\n  }\n  forward() {\n    throw 'not implemented';\n  }\n  getState() {\n    return this.stateChanges[(this.stateChanges.length || 1) - 1];\n  }\n}\n_MockLocationStrategy = MockLocationStrategy;\n_MockLocationStrategy.ɵfac = function _MockLocationStrategy_Factory(t) {\n  return new (t || _MockLocationStrategy)();\n};\n_MockLocationStrategy.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n  token: _MockLocationStrategy,\n  factory: _MockLocationStrategy.ɵfac\n});\n(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(MockLocationStrategy, [{\n    type: Injectable\n  }], () => [], null);\n})();\nclass _MockPopStateEvent {\n  constructor(newUrl) {\n    this.newUrl = newUrl;\n    this.pop = true;\n    this.type = 'popstate';\n  }\n}\n\n/**\n * Parser from https://tools.ietf.org/html/rfc3986#appendix-B\n * ^(([^:/?#]+):)?(//([^/?#]*))?([^?#]*)(\\?([^#]*))?(#(.*))?\n *  12            3  4          5       6  7        8 9\n *\n * Example: http://www.ics.uci.edu/pub/ietf/uri/#Related\n *\n * Results in:\n *\n * $1 = http:\n * $2 = http\n * $3 = //www.ics.uci.edu\n * $4 = www.ics.uci.edu\n * $5 = /pub/ietf/uri/\n * $6 = <undefined>\n * $7 = <undefined>\n * $8 = #Related\n * $9 = Related\n */\nconst urlParse = /^(([^:\\/?#]+):)?(\\/\\/([^\\/?#]*))?([^?#]*)(\\?([^#]*))?(#(.*))?/;\nfunction parseUrl(urlStr, baseHref) {\n  const verifyProtocol = /^((http[s]?|ftp):\\/\\/)/;\n  let serverBase;\n  // URL class requires full URL. If the URL string doesn't start with protocol, we need to add\n  // an arbitrary base URL which can be removed afterward.\n  if (!verifyProtocol.test(urlStr)) {\n    serverBase = 'http://empty.com/';\n  }\n  let parsedUrl;\n  try {\n    parsedUrl = new URL(urlStr, serverBase);\n  } catch (e) {\n    const result = urlParse.exec(serverBase || '' + urlStr);\n    if (!result) {\n      throw new Error(`Invalid URL: ${urlStr} with base: ${baseHref}`);\n    }\n    const hostSplit = result[4].split(':');\n    parsedUrl = {\n      protocol: result[1],\n      hostname: hostSplit[0],\n      port: hostSplit[1] || '',\n      pathname: result[5],\n      search: result[6],\n      hash: result[8]\n    };\n  }\n  if (parsedUrl.pathname && parsedUrl.pathname.indexOf(baseHref) === 0) {\n    parsedUrl.pathname = parsedUrl.pathname.substring(baseHref.length);\n  }\n  return {\n    hostname: !serverBase && parsedUrl.hostname || '',\n    protocol: !serverBase && parsedUrl.protocol || '',\n    port: !serverBase && parsedUrl.port || '',\n    pathname: parsedUrl.pathname || '/',\n    search: parsedUrl.search || '',\n    hash: parsedUrl.hash || ''\n  };\n}\n/**\n * Provider for mock platform location config\n *\n * @publicApi\n */\nconst MOCK_PLATFORM_LOCATION_CONFIG = new InjectionToken('MOCK_PLATFORM_LOCATION_CONFIG');\n/**\n * Mock implementation of URL state.\n *\n * @publicApi\n */\nclass MockPlatformLocation {\n  constructor(config) {\n    this.baseHref = '';\n    this.hashUpdate = new Subject();\n    this.popStateSubject = new Subject();\n    this.urlChangeIndex = 0;\n    this.urlChanges = [{\n      hostname: '',\n      protocol: '',\n      port: '',\n      pathname: '/',\n      search: '',\n      hash: '',\n      state: null\n    }];\n    if (config) {\n      this.baseHref = config.appBaseHref || '';\n      const parsedChanges = this.parseChanges(null, config.startUrl || 'http://_empty_/', this.baseHref);\n      this.urlChanges[0] = {\n        ...parsedChanges\n      };\n    }\n  }\n  get hostname() {\n    return this.urlChanges[this.urlChangeIndex].hostname;\n  }\n  get protocol() {\n    return this.urlChanges[this.urlChangeIndex].protocol;\n  }\n  get port() {\n    return this.urlChanges[this.urlChangeIndex].port;\n  }\n  get pathname() {\n    return this.urlChanges[this.urlChangeIndex].pathname;\n  }\n  get search() {\n    return this.urlChanges[this.urlChangeIndex].search;\n  }\n  get hash() {\n    return this.urlChanges[this.urlChangeIndex].hash;\n  }\n  get state() {\n    return this.urlChanges[this.urlChangeIndex].state;\n  }\n  getBaseHrefFromDOM() {\n    return this.baseHref;\n  }\n  onPopState(fn) {\n    const subscription = this.popStateSubject.subscribe(fn);\n    return () => subscription.unsubscribe();\n  }\n  onHashChange(fn) {\n    const subscription = this.hashUpdate.subscribe(fn);\n    return () => subscription.unsubscribe();\n  }\n  get href() {\n    let url = `${this.protocol}//${this.hostname}${this.port ? ':' + this.port : ''}`;\n    url += `${this.pathname === '/' ? '' : this.pathname}${this.search}${this.hash}`;\n    return url;\n  }\n  get url() {\n    return `${this.pathname}${this.search}${this.hash}`;\n  }\n  parseChanges(state, url, baseHref = '') {\n    // When the `history.state` value is stored, it is always copied.\n    state = JSON.parse(JSON.stringify(state));\n    return {\n      ...parseUrl(url, baseHref),\n      state\n    };\n  }\n  replaceState(state, title, newUrl) {\n    const {\n      pathname,\n      search,\n      state: parsedState,\n      hash\n    } = this.parseChanges(state, newUrl);\n    this.urlChanges[this.urlChangeIndex] = {\n      ...this.urlChanges[this.urlChangeIndex],\n      pathname,\n      search,\n      hash,\n      state: parsedState\n    };\n  }\n  pushState(state, title, newUrl) {\n    const {\n      pathname,\n      search,\n      state: parsedState,\n      hash\n    } = this.parseChanges(state, newUrl);\n    if (this.urlChangeIndex > 0) {\n      this.urlChanges.splice(this.urlChangeIndex + 1);\n    }\n    this.urlChanges.push({\n      ...this.urlChanges[this.urlChangeIndex],\n      pathname,\n      search,\n      hash,\n      state: parsedState\n    });\n    this.urlChangeIndex = this.urlChanges.length - 1;\n  }\n  forward() {\n    const oldUrl = this.url;\n    const oldHash = this.hash;\n    if (this.urlChangeIndex < this.urlChanges.length) {\n      this.urlChangeIndex++;\n    }\n    this.emitEvents(oldHash, oldUrl);\n  }\n  back() {\n    const oldUrl = this.url;\n    const oldHash = this.hash;\n    if (this.urlChangeIndex > 0) {\n      this.urlChangeIndex--;\n    }\n    this.emitEvents(oldHash, oldUrl);\n  }\n  historyGo(relativePosition = 0) {\n    const oldUrl = this.url;\n    const oldHash = this.hash;\n    const nextPageIndex = this.urlChangeIndex + relativePosition;\n    if (nextPageIndex >= 0 && nextPageIndex < this.urlChanges.length) {\n      this.urlChangeIndex = nextPageIndex;\n    }\n    this.emitEvents(oldHash, oldUrl);\n  }\n  getState() {\n    return this.state;\n  }\n  /**\n   * Browsers are inconsistent in when they fire events and perform the state updates\n   * The most easiest thing to do in our mock is synchronous and that happens to match\n   * Firefox and Chrome, at least somewhat closely\n   *\n   * https://github.com/WICG/navigation-api#watching-for-navigations\n   * https://docs.google.com/document/d/1Pdve-DJ1JCGilj9Yqf5HxRJyBKSel5owgOvUJqTauwU/edit#heading=h.3ye4v71wsz94\n   * popstate is always sent before hashchange:\n   * https://developer.mozilla.org/en-US/docs/Web/API/Window/popstate_event#when_popstate_is_sent\n   */\n  emitEvents(oldHash, oldUrl) {\n    this.popStateSubject.next({\n      type: 'popstate',\n      state: this.getState(),\n      oldUrl,\n      newUrl: this.url\n    });\n    if (oldHash !== this.hash) {\n      this.hashUpdate.next({\n        type: 'hashchange',\n        state: null,\n        oldUrl,\n        newUrl: this.url\n      });\n    }\n  }\n}\n_MockPlatformLocation = MockPlatformLocation;\n_MockPlatformLocation.ɵfac = function _MockPlatformLocation_Factory(t) {\n  return new (t || _MockPlatformLocation)(i0.ɵɵinject(MOCK_PLATFORM_LOCATION_CONFIG, 8));\n};\n_MockPlatformLocation.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n  token: _MockPlatformLocation,\n  factory: _MockPlatformLocation.ɵfac\n});\n(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(MockPlatformLocation, [{\n    type: Injectable\n  }], () => [{\n    type: undefined,\n    decorators: [{\n      type: Inject,\n      args: [MOCK_PLATFORM_LOCATION_CONFIG]\n    }, {\n      type: Optional\n    }]\n  }], null);\n})();\n\n/**\n * Returns mock providers for the `Location` and `LocationStrategy` classes.\n * The mocks are helpful in tests to fire simulated location events.\n *\n * @publicApi\n */\nfunction provideLocationMocks() {\n  return [{\n    provide: Location,\n    useClass: SpyLocation\n  }, {\n    provide: LocationStrategy,\n    useClass: MockLocationStrategy\n  }];\n}\n\n/**\n * @module\n * @description\n * Entry point for all public APIs of the common/testing package.\n */\n\n/**\n * @module\n * @description\n * Entry point for all public APIs of this package.\n */\n// This file only reexports content of the `src` folder. Keep it that way.\n\n// This file is not used to build this module. It is only used during editing\n\n/**\n * Generated bundle index. Do not edit.\n */\n\nexport { MOCK_PLATFORM_LOCATION_CONFIG, MockLocationStrategy, MockPlatformLocation, SpyLocation, provideLocationMocks };","map":{"version":3,"names":["ɵnormalizeQueryParams","LocationStrategy","Location","i0","EventEmitter","Injectable","InjectionToken","Inject","Optional","Subject","SpyLocation","constructor","urlChanges","_history","LocationState","_historyIndex","_subject","_basePath","_locationStrategy","_urlChangeListeners","_urlChangeSubscription","ngOnDestroy","_this$_urlChangeSubsc","unsubscribe","setInitialPath","url","path","setBaseHref","getState","state","isCurrentPathEqualTo","query","givenPath","endsWith","substring","length","currPath","simulateUrlPop","pathname","emit","simulateHashChange","prepareExternalUrl","pushHistory","push","startsWith","go","locationState","_notifyUrlChangeListeners","replaceState","history","forward","back","historyGo","relativePosition","nextPageIndex","onUrlChange","fn","_this$_urlChangeSubsc2","subscribe","v","fnIndex","indexOf","splice","_this$_urlChangeSubsc3","forEach","onNext","onThrow","onReturn","next","error","complete","normalize","_SpyLocation","ɵfac","_SpyLocation_Factory","t","ɵprov","ɵɵdefineInjectable","token","factory","ngDevMode","ɵsetClassMetadata","type","MockLocationStrategy","internalBaseHref","internalPath","internalTitle","stateChanges","simulatePopState","_MockPopStateEvent","includeHash","internal","pushState","ctx","title","externalUrl","onPopState","getBaseHref","pop","nextUrl","_MockLocationStrategy","_MockLocationStrategy_Factory","newUrl","urlParse","parseUrl","urlStr","baseHref","verifyProtocol","serverBase","test","parsedUrl","URL","e","result","exec","Error","hostSplit","split","protocol","hostname","port","search","hash","MOCK_PLATFORM_LOCATION_CONFIG","MockPlatformLocation","config","hashUpdate","popStateSubject","urlChangeIndex","appBaseHref","parsedChanges","parseChanges","startUrl","getBaseHrefFromDOM","subscription","onHashChange","href","JSON","parse","stringify","parsedState","oldUrl","oldHash","emitEvents","_MockPlatformLocation","_MockPlatformLocation_Factory","ɵɵinject","undefined","decorators","args","provideLocationMocks","provide","useClass"],"sources":["C:/Users/MacBook Air/Desktop/shifai1VV/node_modules/@angular/common/fesm2022/testing.mjs"],"sourcesContent":["/**\n * @license Angular v17.1.2\n * (c) 2010-2022 Google LLC. https://angular.io/\n * License: MIT\n */\n\nimport { ɵnormalizeQueryParams, LocationStrategy, Location } from '@angular/common';\nimport * as i0 from '@angular/core';\nimport { EventEmitter, Injectable, InjectionToken, Inject, Optional } from '@angular/core';\nimport { Subject } from 'rxjs';\n\n/**\n * A spy for {@link Location} that allows tests to fire simulated location events.\n *\n * @publicApi\n */\nclass SpyLocation {\n    constructor() {\n        this.urlChanges = [];\n        this._history = [new LocationState('', '', null)];\n        this._historyIndex = 0;\n        /** @internal */\n        this._subject = new EventEmitter();\n        /** @internal */\n        this._basePath = '';\n        /** @internal */\n        this._locationStrategy = null;\n        /** @internal */\n        this._urlChangeListeners = [];\n        /** @internal */\n        this._urlChangeSubscription = null;\n    }\n    /** @nodoc */\n    ngOnDestroy() {\n        this._urlChangeSubscription?.unsubscribe();\n        this._urlChangeListeners = [];\n    }\n    setInitialPath(url) {\n        this._history[this._historyIndex].path = url;\n    }\n    setBaseHref(url) {\n        this._basePath = url;\n    }\n    path() {\n        return this._history[this._historyIndex].path;\n    }\n    getState() {\n        return this._history[this._historyIndex].state;\n    }\n    isCurrentPathEqualTo(path, query = '') {\n        const givenPath = path.endsWith('/') ? path.substring(0, path.length - 1) : path;\n        const currPath = this.path().endsWith('/')\n            ? this.path().substring(0, this.path().length - 1)\n            : this.path();\n        return currPath == givenPath + (query.length > 0 ? '?' + query : '');\n    }\n    simulateUrlPop(pathname) {\n        this._subject.emit({ 'url': pathname, 'pop': true, 'type': 'popstate' });\n    }\n    simulateHashChange(pathname) {\n        const path = this.prepareExternalUrl(pathname);\n        this.pushHistory(path, '', null);\n        this.urlChanges.push('hash: ' + pathname);\n        // the browser will automatically fire popstate event before each `hashchange` event, so we need\n        // to simulate it.\n        this._subject.emit({ 'url': pathname, 'pop': true, 'type': 'popstate' });\n        this._subject.emit({ 'url': pathname, 'pop': true, 'type': 'hashchange' });\n    }\n    prepareExternalUrl(url) {\n        if (url.length > 0 && !url.startsWith('/')) {\n            url = '/' + url;\n        }\n        return this._basePath + url;\n    }\n    go(path, query = '', state = null) {\n        path = this.prepareExternalUrl(path);\n        this.pushHistory(path, query, state);\n        const locationState = this._history[this._historyIndex - 1];\n        if (locationState.path == path && locationState.query == query) {\n            return;\n        }\n        const url = path + (query.length > 0 ? '?' + query : '');\n        this.urlChanges.push(url);\n        this._notifyUrlChangeListeners(path + ɵnormalizeQueryParams(query), state);\n    }\n    replaceState(path, query = '', state = null) {\n        path = this.prepareExternalUrl(path);\n        const history = this._history[this._historyIndex];\n        history.state = state;\n        if (history.path == path && history.query == query) {\n            return;\n        }\n        history.path = path;\n        history.query = query;\n        const url = path + (query.length > 0 ? '?' + query : '');\n        this.urlChanges.push('replace: ' + url);\n        this._notifyUrlChangeListeners(path + ɵnormalizeQueryParams(query), state);\n    }\n    forward() {\n        if (this._historyIndex < this._history.length - 1) {\n            this._historyIndex++;\n            this._subject.emit({\n                'url': this.path(),\n                'state': this.getState(),\n                'pop': true,\n                'type': 'popstate',\n            });\n        }\n    }\n    back() {\n        if (this._historyIndex > 0) {\n            this._historyIndex--;\n            this._subject.emit({\n                'url': this.path(),\n                'state': this.getState(),\n                'pop': true,\n                'type': 'popstate',\n            });\n        }\n    }\n    historyGo(relativePosition = 0) {\n        const nextPageIndex = this._historyIndex + relativePosition;\n        if (nextPageIndex >= 0 && nextPageIndex < this._history.length) {\n            this._historyIndex = nextPageIndex;\n            this._subject.emit({\n                'url': this.path(),\n                'state': this.getState(),\n                'pop': true,\n                'type': 'popstate',\n            });\n        }\n    }\n    onUrlChange(fn) {\n        this._urlChangeListeners.push(fn);\n        this._urlChangeSubscription ??= this.subscribe((v) => {\n            this._notifyUrlChangeListeners(v.url, v.state);\n        });\n        return () => {\n            const fnIndex = this._urlChangeListeners.indexOf(fn);\n            this._urlChangeListeners.splice(fnIndex, 1);\n            if (this._urlChangeListeners.length === 0) {\n                this._urlChangeSubscription?.unsubscribe();\n                this._urlChangeSubscription = null;\n            }\n        };\n    }\n    /** @internal */\n    _notifyUrlChangeListeners(url = '', state) {\n        this._urlChangeListeners.forEach((fn) => fn(url, state));\n    }\n    subscribe(onNext, onThrow, onReturn) {\n        return this._subject.subscribe({ next: onNext, error: onThrow, complete: onReturn });\n    }\n    normalize(url) {\n        return null;\n    }\n    pushHistory(path, query, state) {\n        if (this._historyIndex > 0) {\n            this._history.splice(this._historyIndex + 1);\n        }\n        this._history.push(new LocationState(path, query, state));\n        this._historyIndex = this._history.length - 1;\n    }\n    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"17.1.2\", ngImport: i0, type: SpyLocation, deps: [], target: i0.ɵɵFactoryTarget.Injectable }); }\n    static { this.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: \"12.0.0\", version: \"17.1.2\", ngImport: i0, type: SpyLocation }); }\n}\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"17.1.2\", ngImport: i0, type: SpyLocation, decorators: [{\n            type: Injectable\n        }] });\nclass LocationState {\n    constructor(path, query, state) {\n        this.path = path;\n        this.query = query;\n        this.state = state;\n    }\n}\n\n/**\n * A mock implementation of {@link LocationStrategy} that allows tests to fire simulated\n * location events.\n *\n * @publicApi\n */\nclass MockLocationStrategy extends LocationStrategy {\n    constructor() {\n        super();\n        this.internalBaseHref = '/';\n        this.internalPath = '/';\n        this.internalTitle = '';\n        this.urlChanges = [];\n        /** @internal */\n        this._subject = new EventEmitter();\n        this.stateChanges = [];\n    }\n    simulatePopState(url) {\n        this.internalPath = url;\n        this._subject.emit(new _MockPopStateEvent(this.path()));\n    }\n    path(includeHash = false) {\n        return this.internalPath;\n    }\n    prepareExternalUrl(internal) {\n        if (internal.startsWith('/') && this.internalBaseHref.endsWith('/')) {\n            return this.internalBaseHref + internal.substring(1);\n        }\n        return this.internalBaseHref + internal;\n    }\n    pushState(ctx, title, path, query) {\n        // Add state change to changes array\n        this.stateChanges.push(ctx);\n        this.internalTitle = title;\n        const url = path + (query.length > 0 ? '?' + query : '');\n        this.internalPath = url;\n        const externalUrl = this.prepareExternalUrl(url);\n        this.urlChanges.push(externalUrl);\n    }\n    replaceState(ctx, title, path, query) {\n        // Reset the last index of stateChanges to the ctx (state) object\n        this.stateChanges[(this.stateChanges.length || 1) - 1] = ctx;\n        this.internalTitle = title;\n        const url = path + (query.length > 0 ? '?' + query : '');\n        this.internalPath = url;\n        const externalUrl = this.prepareExternalUrl(url);\n        this.urlChanges.push('replace: ' + externalUrl);\n    }\n    onPopState(fn) {\n        this._subject.subscribe({ next: fn });\n    }\n    getBaseHref() {\n        return this.internalBaseHref;\n    }\n    back() {\n        if (this.urlChanges.length > 0) {\n            this.urlChanges.pop();\n            this.stateChanges.pop();\n            const nextUrl = this.urlChanges.length > 0 ? this.urlChanges[this.urlChanges.length - 1] : '';\n            this.simulatePopState(nextUrl);\n        }\n    }\n    forward() {\n        throw 'not implemented';\n    }\n    getState() {\n        return this.stateChanges[(this.stateChanges.length || 1) - 1];\n    }\n    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"17.1.2\", ngImport: i0, type: MockLocationStrategy, deps: [], target: i0.ɵɵFactoryTarget.Injectable }); }\n    static { this.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: \"12.0.0\", version: \"17.1.2\", ngImport: i0, type: MockLocationStrategy }); }\n}\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"17.1.2\", ngImport: i0, type: MockLocationStrategy, decorators: [{\n            type: Injectable\n        }], ctorParameters: () => [] });\nclass _MockPopStateEvent {\n    constructor(newUrl) {\n        this.newUrl = newUrl;\n        this.pop = true;\n        this.type = 'popstate';\n    }\n}\n\n/**\n * Parser from https://tools.ietf.org/html/rfc3986#appendix-B\n * ^(([^:/?#]+):)?(//([^/?#]*))?([^?#]*)(\\?([^#]*))?(#(.*))?\n *  12            3  4          5       6  7        8 9\n *\n * Example: http://www.ics.uci.edu/pub/ietf/uri/#Related\n *\n * Results in:\n *\n * $1 = http:\n * $2 = http\n * $3 = //www.ics.uci.edu\n * $4 = www.ics.uci.edu\n * $5 = /pub/ietf/uri/\n * $6 = <undefined>\n * $7 = <undefined>\n * $8 = #Related\n * $9 = Related\n */\nconst urlParse = /^(([^:\\/?#]+):)?(\\/\\/([^\\/?#]*))?([^?#]*)(\\?([^#]*))?(#(.*))?/;\nfunction parseUrl(urlStr, baseHref) {\n    const verifyProtocol = /^((http[s]?|ftp):\\/\\/)/;\n    let serverBase;\n    // URL class requires full URL. If the URL string doesn't start with protocol, we need to add\n    // an arbitrary base URL which can be removed afterward.\n    if (!verifyProtocol.test(urlStr)) {\n        serverBase = 'http://empty.com/';\n    }\n    let parsedUrl;\n    try {\n        parsedUrl = new URL(urlStr, serverBase);\n    }\n    catch (e) {\n        const result = urlParse.exec(serverBase || '' + urlStr);\n        if (!result) {\n            throw new Error(`Invalid URL: ${urlStr} with base: ${baseHref}`);\n        }\n        const hostSplit = result[4].split(':');\n        parsedUrl = {\n            protocol: result[1],\n            hostname: hostSplit[0],\n            port: hostSplit[1] || '',\n            pathname: result[5],\n            search: result[6],\n            hash: result[8],\n        };\n    }\n    if (parsedUrl.pathname && parsedUrl.pathname.indexOf(baseHref) === 0) {\n        parsedUrl.pathname = parsedUrl.pathname.substring(baseHref.length);\n    }\n    return {\n        hostname: (!serverBase && parsedUrl.hostname) || '',\n        protocol: (!serverBase && parsedUrl.protocol) || '',\n        port: (!serverBase && parsedUrl.port) || '',\n        pathname: parsedUrl.pathname || '/',\n        search: parsedUrl.search || '',\n        hash: parsedUrl.hash || '',\n    };\n}\n/**\n * Provider for mock platform location config\n *\n * @publicApi\n */\nconst MOCK_PLATFORM_LOCATION_CONFIG = new InjectionToken('MOCK_PLATFORM_LOCATION_CONFIG');\n/**\n * Mock implementation of URL state.\n *\n * @publicApi\n */\nclass MockPlatformLocation {\n    constructor(config) {\n        this.baseHref = '';\n        this.hashUpdate = new Subject();\n        this.popStateSubject = new Subject();\n        this.urlChangeIndex = 0;\n        this.urlChanges = [{ hostname: '', protocol: '', port: '', pathname: '/', search: '', hash: '', state: null }];\n        if (config) {\n            this.baseHref = config.appBaseHref || '';\n            const parsedChanges = this.parseChanges(null, config.startUrl || 'http://_empty_/', this.baseHref);\n            this.urlChanges[0] = { ...parsedChanges };\n        }\n    }\n    get hostname() {\n        return this.urlChanges[this.urlChangeIndex].hostname;\n    }\n    get protocol() {\n        return this.urlChanges[this.urlChangeIndex].protocol;\n    }\n    get port() {\n        return this.urlChanges[this.urlChangeIndex].port;\n    }\n    get pathname() {\n        return this.urlChanges[this.urlChangeIndex].pathname;\n    }\n    get search() {\n        return this.urlChanges[this.urlChangeIndex].search;\n    }\n    get hash() {\n        return this.urlChanges[this.urlChangeIndex].hash;\n    }\n    get state() {\n        return this.urlChanges[this.urlChangeIndex].state;\n    }\n    getBaseHrefFromDOM() {\n        return this.baseHref;\n    }\n    onPopState(fn) {\n        const subscription = this.popStateSubject.subscribe(fn);\n        return () => subscription.unsubscribe();\n    }\n    onHashChange(fn) {\n        const subscription = this.hashUpdate.subscribe(fn);\n        return () => subscription.unsubscribe();\n    }\n    get href() {\n        let url = `${this.protocol}//${this.hostname}${this.port ? ':' + this.port : ''}`;\n        url += `${this.pathname === '/' ? '' : this.pathname}${this.search}${this.hash}`;\n        return url;\n    }\n    get url() {\n        return `${this.pathname}${this.search}${this.hash}`;\n    }\n    parseChanges(state, url, baseHref = '') {\n        // When the `history.state` value is stored, it is always copied.\n        state = JSON.parse(JSON.stringify(state));\n        return { ...parseUrl(url, baseHref), state };\n    }\n    replaceState(state, title, newUrl) {\n        const { pathname, search, state: parsedState, hash } = this.parseChanges(state, newUrl);\n        this.urlChanges[this.urlChangeIndex] = {\n            ...this.urlChanges[this.urlChangeIndex],\n            pathname,\n            search,\n            hash,\n            state: parsedState,\n        };\n    }\n    pushState(state, title, newUrl) {\n        const { pathname, search, state: parsedState, hash } = this.parseChanges(state, newUrl);\n        if (this.urlChangeIndex > 0) {\n            this.urlChanges.splice(this.urlChangeIndex + 1);\n        }\n        this.urlChanges.push({\n            ...this.urlChanges[this.urlChangeIndex],\n            pathname,\n            search,\n            hash,\n            state: parsedState,\n        });\n        this.urlChangeIndex = this.urlChanges.length - 1;\n    }\n    forward() {\n        const oldUrl = this.url;\n        const oldHash = this.hash;\n        if (this.urlChangeIndex < this.urlChanges.length) {\n            this.urlChangeIndex++;\n        }\n        this.emitEvents(oldHash, oldUrl);\n    }\n    back() {\n        const oldUrl = this.url;\n        const oldHash = this.hash;\n        if (this.urlChangeIndex > 0) {\n            this.urlChangeIndex--;\n        }\n        this.emitEvents(oldHash, oldUrl);\n    }\n    historyGo(relativePosition = 0) {\n        const oldUrl = this.url;\n        const oldHash = this.hash;\n        const nextPageIndex = this.urlChangeIndex + relativePosition;\n        if (nextPageIndex >= 0 && nextPageIndex < this.urlChanges.length) {\n            this.urlChangeIndex = nextPageIndex;\n        }\n        this.emitEvents(oldHash, oldUrl);\n    }\n    getState() {\n        return this.state;\n    }\n    /**\n     * Browsers are inconsistent in when they fire events and perform the state updates\n     * The most easiest thing to do in our mock is synchronous and that happens to match\n     * Firefox and Chrome, at least somewhat closely\n     *\n     * https://github.com/WICG/navigation-api#watching-for-navigations\n     * https://docs.google.com/document/d/1Pdve-DJ1JCGilj9Yqf5HxRJyBKSel5owgOvUJqTauwU/edit#heading=h.3ye4v71wsz94\n     * popstate is always sent before hashchange:\n     * https://developer.mozilla.org/en-US/docs/Web/API/Window/popstate_event#when_popstate_is_sent\n     */\n    emitEvents(oldHash, oldUrl) {\n        this.popStateSubject.next({\n            type: 'popstate',\n            state: this.getState(),\n            oldUrl,\n            newUrl: this.url,\n        });\n        if (oldHash !== this.hash) {\n            this.hashUpdate.next({\n                type: 'hashchange',\n                state: null,\n                oldUrl,\n                newUrl: this.url,\n            });\n        }\n    }\n    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"17.1.2\", ngImport: i0, type: MockPlatformLocation, deps: [{ token: MOCK_PLATFORM_LOCATION_CONFIG, optional: true }], target: i0.ɵɵFactoryTarget.Injectable }); }\n    static { this.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: \"12.0.0\", version: \"17.1.2\", ngImport: i0, type: MockPlatformLocation }); }\n}\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"17.1.2\", ngImport: i0, type: MockPlatformLocation, decorators: [{\n            type: Injectable\n        }], ctorParameters: () => [{ type: undefined, decorators: [{\n                    type: Inject,\n                    args: [MOCK_PLATFORM_LOCATION_CONFIG]\n                }, {\n                    type: Optional\n                }] }] });\n\n/**\n * Returns mock providers for the `Location` and `LocationStrategy` classes.\n * The mocks are helpful in tests to fire simulated location events.\n *\n * @publicApi\n */\nfunction provideLocationMocks() {\n    return [\n        { provide: Location, useClass: SpyLocation },\n        { provide: LocationStrategy, useClass: MockLocationStrategy },\n    ];\n}\n\n/**\n * @module\n * @description\n * Entry point for all public APIs of the common/testing package.\n */\n\n/**\n * @module\n * @description\n * Entry point for all public APIs of this package.\n */\n// This file only reexports content of the `src` folder. Keep it that way.\n\n// This file is not used to build this module. It is only used during editing\n\n/**\n * Generated bundle index. Do not edit.\n */\n\nexport { MOCK_PLATFORM_LOCATION_CONFIG, MockLocationStrategy, MockPlatformLocation, SpyLocation, provideLocationMocks };\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}